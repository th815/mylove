<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>《致亲爱的刘春迪》</title>
    <link type="text/css" rel="stylesheet" href="./static/default.css">
    <script type="text/javascript" src="./static/jquery.min.js"></script>
    <script type="text/javascript" src="./static/jscex.min.js"></script>
    <script type="text/javascript" src="./static/jscex-parser.js"></script>
    <script type="text/javascript" src="./static/jscex-jit.js"></script>
    <script type="text/javascript" src="./static/jscex-builderbase.min.js"></script>
    <script type="text/javascript" src="./static/jscex-async.min.js"></script>
    <script type="text/javascript" src="./static/jscex-async-powerpack.min.js"></script>
    <script type="text/javascript" src="./static/functions.js" charset="utf-8"></script>
    <script type="text/javascript" src="./static/love.js" charset="utf-8"></script>
</head>

<body>

<!-- 修复1: 恢复 muted 属性，确保符合浏览器自动播放策略 -->
<audio id="bgm" autoplay muted loop>
    <source src="./static/TheFlood.mp3" type="audio/mp3" />
</audio>

<div id="main">
    <div id="error">本页面采用HTML5编辑，目前您的浏览器无法显示，请换成谷歌(<a
            href="http://www.google.cn/chrome/intl/zh-CN/landing_chrome.html?hl=zh-CN&brand=CHMI">Chrome</a>)或者火狐(<a
            href="http://firefox.com.cn/download/">Firefox</a>)浏览器，或者其他游览器的最新版本。</div>

    <div id="wrap">
        <div id="text">
            <div id="code">
                <font color="#FF0000">
                    <span class="say">亲爱的刘春迪，</span><br>
                    <span class="say">我们的故事，从2025年8月27日晚上9点16分开始。</span><br>
                    <span class="say">那天加上好友的瞬间，我没想到，会在之后的日子里，一直点亮我的生活。</span><br>
                    <br>
                    <span class="say">9月23日的夜晚，你认真地说出心里的顾虑，那一刻让我明白，喜欢一个人并不轻松。</span><br>
                    <span class="say">可正是那种拉扯与不确定，让我更加确定，我想要留下来。</span><br>
                    <br>
                    <span class="say">后来，我们真正亲吻的那一刻，我知道，我们的心已经交换了答案。</span><br>
                    <span class="say">从那天起，我就更愿意相信，相遇不是偶然，而是注定。</span><br>
                    <br>
                    <span class="say">我不知道未来会怎样，但我知道，今天的我，很喜欢你。</span><br>
                    <span class="say"><span class="space"></span>—— 永远爱你的 田昊</span><br>
                </font>
            </div>
        </div>

        <div id="clock-box">
            <span class="STYLE1"></span>
            <font color="#D6336C">亲爱的刘春迪，</font><br>
            <font color="#FF6699">我们的故事开始，已经……</font><br>
            <div id="clock"></div>
        </div>

        <canvas id="canvas" width="1100" height="680"></canvas>
    </div>

    <!-- 歌词显示区域 -->
    <div id="lyric-box">
        <div id="lyric-en"></div>
        <div id="lyric-cn"></div>
    </div>
</div>

<script>
    (function () {
        const $canvas = $('#canvas');
        const canvasEl = $canvas[0];

        if (!canvasEl.getContext) {
            $('#error').show();
            return;
        }

        const BASE_CANVAS = { width: 1100, height: 680 };
        const HEART_OFFSET = 20;
        const BASE_BRANCHES = [
            [535, 680, 570, 250, 500, 200, 30, 100, [
                [540, 500, 455, 417, 340, 400, 13, 100, [
                    [450, 435, 434, 430, 394, 395, 2, 40]
                ]],
                [550, 445, 600, 356, 680, 345, 12, 100, [
                    [578, 400, 648, 409, 661, 426, 3, 80]
                ]],
                [539, 281, 537, 248, 534, 217, 3, 40],
                [546, 397, 413, 247, 328, 244, 9, 80, [
                    [427, 286, 383, 253, 371, 205, 2, 40],
                    [498, 345, 435, 315, 395, 330, 4, 60]
                ]],
                [546, 357, 608, 252, 678, 221, 6, 100, [
                    [590, 293, 646, 277, 648, 271, 2, 80]
                ]]
            ]]
        ];
        const BASE_BLOOM_COUNT = 700;
        const BASE_FOOTER = { width: 1200, height: 5, speed: 10 };
        const BASE_MOVE = { snapshotStartX: 240, moveTargetX: 500, snapshotWidth: 610 };

        const computeMetrics = () => {
            const rect = canvasEl.getBoundingClientRect();
            const availableWidth = rect.width || canvasEl.offsetWidth || window.innerWidth || BASE_CANVAS.width;
            const width = Math.min(availableWidth, BASE_CANVAS.width);
            const scale = width / BASE_CANVAS.width || 1;
            const height = Math.max(120, Math.round(BASE_CANVAS.height * scale));
            return { width, height, scale };
        };

        const scaleBranch = (branch, scale) => {
            const scaled = [
                branch[0] * scale,
                branch[1] * scale,
                branch[2] * scale,
                branch[3] * scale,
                branch[4] * scale,
                branch[5] * scale,
                Math.max(1.2, branch[6] * scale),
                Math.max(8, Math.round(branch[7] * scale))
            ];

            if (branch[8]) {
                scaled.push(branch[8].map(child => scaleBranch(child, scale)));
            }

            return scaled;
        };

        const createTreeOptions = ({ width, height, scale }) => ({
            seed: {
                x: width / 2 - HEART_OFFSET * scale,
                color: 'rgb(190, 26, 37)',
                scale: Math.max(1.2, 2 * scale)
            },
            branch: BASE_BRANCHES.map(branch => scaleBranch(branch, scale)),
            bloom: {
                num: Math.max(220, Math.round(BASE_BLOOM_COUNT * Math.max(scale, 0.68))),
                width,
                height
            },
            footer: {
                width: Math.max(width * 1.2, BASE_FOOTER.width * scale),
                height: Math.max(3, BASE_FOOTER.height * scale),
                speed: BASE_FOOTER.speed
            }
        });

        const metrics = computeMetrics();
        const { width, height, scale } = metrics;
        const dpr = window.devicePixelRatio || 1;

        canvasEl.width = Math.round(width * dpr);
        canvasEl.height = Math.round(height * dpr);
        $canvas.css({ width: `${width}px`, height: `${height}px` });

        if (dpr !== 1) {
            const ctx = canvasEl.getContext('2d');
            ctx.scale(dpr, dpr);
        }

        const tree = new Tree(canvasEl, width, height, createTreeOptions(metrics));
        const wrap = $canvas.parent();
        const seed = tree.seed;
        const foot = tree.footer;
        let hold = 1;

        const pointerHandler = callback => event => {
            const offset = $canvas.offset();
            const x = event.pageX - offset.left;
            const y = event.pageY - offset.top;
            callback(x, y, event);
        };

        $canvas.on('click', pointerHandler((x, y) => {
            if (seed.hover(x, y)) {
                hold = 0;
                $canvas.off('click');
                $canvas.off('mousemove');
                $canvas.removeClass('hand');
            }
        }));

        $canvas.on('mousemove', pointerHandler((x, y) => {
            $canvas.toggleClass('hand', seed.hover(x, y));
        }));

        const scaledMove = {
            snapshotStartX: Math.max(0, Math.round(BASE_MOVE.snapshotStartX * scale)),
            snapshotWidth: Math.max(1, Math.round(BASE_MOVE.snapshotWidth * scale)),
            moveTargetX: Math.max(0, Math.round(BASE_MOVE.moveTargetX * scale)),
            snapshotHeight: height
        };
        const movementStep = Math.max(1.4, 2 * scale);
        const bloomStep = Math.max(1, Math.round(2 * Math.max(scale, 0.6)));

        const seedAnimate = eval(Jscex.compile('async', function () {
            seed.draw();
            while (hold) {
                $await(Jscex.Async.sleep(10));
            }
            while (seed.canScale()) {
                seed.scale(0.95);
                $await(Jscex.Async.sleep(10));
            }
            while (seed.canMove()) {
                seed.move(0, movementStep);
                foot.draw();
                $await(Jscex.Async.sleep(10));
            }
        }));

        const growAnimate = eval(Jscex.compile('async', function () {
            do {
                tree.grow();
                $await(Jscex.Async.sleep(10));
            } while (tree.canGrow());
        }));

        const flowAnimate = eval(Jscex.compile('async', function () {
            do {
                tree.flower(bloomStep);
                $await(Jscex.Async.sleep(10));
            } while (tree.canFlower());
        }));

        const moveAnimate = eval(Jscex.compile('async', function () {
            tree.snapshot('p1', scaledMove.snapshotStartX, 0, scaledMove.snapshotWidth, scaledMove.snapshotHeight);
            while (tree.move('p1', scaledMove.moveTargetX, 0)) {
                foot.draw();
                $await(Jscex.Async.sleep(10));
            }
            foot.draw();
            tree.snapshot('p2', scaledMove.moveTargetX, 0, scaledMove.snapshotWidth, scaledMove.snapshotHeight);
            wrap.css({
                'background-image': `url(${tree.toDataURL('image/png')})`,
                'background-repeat': 'no-repeat',
                'background-size': 'contain',
                'background-position': 'center bottom'
            });
            $canvas.css({
                'background-color': '#ffe',
                'background-image': 'none'
            });
            $await(Jscex.Async.sleep(300));
            $canvas.css({
                'background-color': 'transparent',
                'background-image': 'none'
            });
        }));

        const jumpAnimate = eval(Jscex.compile('async', function () {
            while (true) {
                tree.ctx.clearRect(0, 0, width, height);
                tree.jump();
                foot.draw();
                $await(Jscex.Async.sleep(25));
            }
        }));

        const textAnimate = eval(Jscex.compile('async', function () {
            const together = new Date();
            together.setFullYear(2025, 7, 27);
            together.setHours(21);
            together.setMinutes(16);
            together.setSeconds(0);
            together.setMilliseconds(0);
            $('#code').show().typewriter();
            $('#clock-box').fadeIn(500);
            while (true) {
                timeElapse(together);
                $await(Jscex.Async.sleep(1000));
            }
        }));

        const runAsync = eval(Jscex.compile('async', function () {
            $await(seedAnimate());
            $await(growAnimate());
            $await(flowAnimate());
            $await(moveAnimate());
            textAnimate().start();
            $await(jumpAnimate());
        }));

        runAsync().start();

        const lyrics = [
            { time: 13.036, en: "Oh well how times have changed", cn: "时过境迁 沧海桑田" },
            { time: 18.017, en: "Got the world in your hands", cn: "空洞凝视" },
            { time: 19.273, en: "but an empty gaze", cn: "掌心的世界" },
            { time: 22.926, en: "Like Diving under a tidal wave", cn: "如潜入漫卷潮汐之间" },
            { time: 27.864, en: "Yeah I know how it feels", cn: "我也曾亲历" },
            { time: 29.284, en: "when the levee breaks", cn: "溃堤之感" },
            { time: 33.354, en: "Hold your breath", cn: "屏息凝神" },
            { time: 36.466, en: "Take my hand", cn: "握紧我的手" },
            { time: 38.577, en: "Don't you know you're not alone", cn: "你知道你并非孑然一身" },
            { time: 43.645, en: "Cuz I won't lose you in the water", cn: "我不会任湍流冲散彼此" },
            { time: 47.428, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 50.969, en: "It floods", cn: "席卷而来" },
            { time: 53.258, en: "No I won't lose you in the water", cn: "我不会任湍流冲散彼此" },
            { time: 57.560, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 61.052, en: "It floods", cn: "席卷而来" },
            { time: 84.612, en: "Alright don't float away", cn: "不要放弃信念" },
            { time: 89.256, en: "With your head in the clouds", cn: "当你迷失于" },
            { time: 90.670, en: "like a northern haze", cn: "层云厚雾" },
            { time: 94.344, en: "Closing in and the sky is grey", cn: "天际灰霭朦胧" },
            { time: 99.385, en: "Keep an eye on the tide", cn: "务必留心紧逼的潮水" },
            { time: 100.789, en: "when it starts to rain", cn: "骤降的雨滴" },
            { time: 104.710, en: "Hold your breath", cn: "屏息凝神" },
            { time: 107.960, en: "Take my hand", cn: "握紧我的手" },
            { time: 109.420, en: "Don't you know you're not alone", cn: "你知道你并非孑然一身" },
            { time: 114.772, en: "Cuz I won't lose you in the water", cn: "我不会任湍流冲散彼此" },
            { time: 118.801, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 122.394, en: "It floods", cn: "席卷而来" },
            { time: 125.015, en: "No I won't lose you in the water", cn: "我不会任湍流冲散彼此" },
            { time: 129.092, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 132.696, en: "It floods", cn: "席卷而来" },
            { time: 155.509, en: "Cuz I won't lose you in the water", cn: "不要放弃信念" },
            { time: 159.521, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 163.093, en: "It floods", cn: "席卷而来" },
            { time: 165.558, en: "No I won't lose you in the water", cn: "我不会任湍流冲散彼此" },
            { time: 169.968, en: "When the river floods", cn: "纵使浪潮滔天" },
            { time: 173.551, en: "It floods", cn: "我们无所畏惧" }
        ];

        const audio = document.getElementById('bgm');
        const lyricEn = document.getElementById('lyric-en');
        const lyricCn = document.getElementById('lyric-cn');
        let currentIndex = -1;

        audio.addEventListener('timeupdate', () => {
            for (let i = 0; i < lyrics.length; i += 1) {
                const current = lyrics[i];
                const next = lyrics[i + 1];
                if (audio.currentTime >= current.time && (!next || audio.currentTime < next.time)) {
                    if (currentIndex !== i) {
                        lyricEn.textContent = current.en;
                        lyricCn.textContent = current.cn;
                        currentIndex = i;
                    }
                    break;
                }
            }
        });

        let audioUnlocked = false;
        const unlockAudio = () => {
            if (audioUnlocked) {
                return;
            }
            audioUnlocked = true;
            audio.muted = false;
            audio.play().catch(() => {});
        };

        ['click', 'touchstart'].forEach(eventName => {
            window.addEventListener(eventName, unlockAudio, { once: true });
        });
    })();
</script>

</body>
</html>
